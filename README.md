
# TikTok-Chat 前端

这是一个基于 **Vue 3 + Vite + Element Plus** 的前端项目，用于演示一个带会话管理的 AI 聊天界面。
- 注：老师您好！这个项目是从我另外一个项目改造过来的，所以现在有点“阉割”，可能会让体验感差一点，如果要看我完整的项目，请访问：https://github.com/tudou999/project_gdgs_frontend 。如果需要后端的支持，请在飞书联系我，我可以提供后端的容器！

## 一、项目功能概述

- **用户登录**
  - 使用邮箱 + 密码登录（通过 Mock 接口模拟校验）。
  - 登录成功后自动跳转到 AI 聊天页面。

- **会话管理（左侧侧边栏）**
  - 展示会话列表（聊天记录列表）。
  - 支持：
    - 新建会话
    - 重命名会话（行内编辑，输入框 + 确认 / 取消按钮）
    - 删除会话
  - 使用内存 Mock 状态保存对会话标题和列表的修改，在当前运行期间有效。

- **对话记录与分页（右侧主区域）**
  - 展示当前选中会话的消息列表。
  - 点击不同会话会加载对应的对话消息。
  - 向上滚动到顶部时自动加载更多历史消息（分页加载）。

- **AI 聊天体验**
  - 底部输入框支持多行输入（回车发送），并提供发送按钮。
  - 支持“本地 / 在线”模式切换（通过开关切换 `mode` 参数）。
  - 使用打字机效果实现流式输出。
  - 开发环境下，聊天接口会从 Mock 数据中返回流式内容，无需真实后端即可体验效果。

- **消息展示增强**
  - AI 回复支持 Markdown 渲染与代码高亮（highlight.js）。
  - 支持复制用户消息和 AI 消息内容。
  - 用户消息支持“重新生成”功能（将这条提问再次发送）。

## 二、运行环境要求

- Node.js：`^20.19.0` 或 `>=22.12.0`
- npm（或兼容的包管理器）

## 三、安装与运行指令

在项目根目录执行以下命令。

### 1. 安装依赖

```sh
npm install
```

### 2. 启动开发环境

```sh
npm run dev
```

启动成功后，按照终端提示在浏览器访问（通常为）：

```text
http://localhost:5173
```

### 3. 构建生产环境代码

```sh
npm run build
```

打包产物默认输出到 `dist/` 目录，可配合任意静态服务器部署。

### 4. 预览打包结果

```sh
npm run preview
```

该命令会以本地静态服务器的方式预览 `dist/` 内容，方便检查打包结果。

### 5. 代码检查与格式化

- 使用 ESLint 自动修复：

```sh
npm run lint
```

- 使用 Prettier 格式化 `src/` 下代码：

```sh
npm run format
```

## 四、Mock 行为说明（开发环境）

- 所有以 `/api/v1` 开头的接口在开发环境下会被 Axios 拦截，根据 URL 和 Method 匹配到 `public/mock/` 中的 JSON 文件或内存处理函数。
- 会话相关接口（列表 / 创建 / 重命名 / 删除）使用内存变量保存状态：
  - 首次从 `mock_session_list.json` 读取初始数据。
  - 之后的修改（重命名 / 删除 / 新建）只保存在当前运行周期的内存中。
- 对话消息分页接口会根据 `sessionId` 加载不同的 `mock_message_page_{id}.json`，用于模拟不同会话的聊天记录。
- 聊天流接口在开发模式下会从 Mock 文本/配置中以“分片”的形式返回数据，用于模拟真实的流式响应。

## 五、技术栈

- 框架：Vue 3（`<script setup>` 语法）
- 构建工具：Vite
- UI 组件：Element Plus
- 状态管理：Pinia
- 路由：Vue Router
- HTTP 客户端：Axios
- Markdown 渲染：marked + DOMPurify
- 代码高亮：highlight.js

如需接入真实后端，只需要按接口约定替换 Mock 配置，即可无缝切换到真实服务。

## 六、整体设计思路

- **单页应用 + 双栏布局**
  - 顶层使用 `AIChat.vue` 作为主页面容器，左侧为会话列表，右侧通过 `<router-view>` 渲染聊天内容组件（默认是 `ChatRecord.vue`）。
  - 通过固定高度 + 内层滚动容器的方式，保证在不同分辨率下都有稳定的布局体验。

- **会话驱动的聊天模型**
  - 页面核心状态是 `currentChatId`：
    - 左侧点击会话菜单时更新 `currentChatId`；
    - 右侧 `ChatRecord` 通过 `props.chatId` 响应变化并加载对应消息。
  - 新建会话时暂时使用 `chatId = 0` 作为本地临时会话，真正发送第一条消息时再通过接口创建真实会话并回写 ID。

- **解耦会话与消息**
  - 会话列表：通过 `/session` 系列接口（Mock）维护，只关心 ID / 标题等元信息。
  - 消息列表：通过 `/message/session/{id}/page` 接口分页获取，组件内部只依赖通用字段（`senderType`、`contents` 等），后端返回由适配层统一转换。

- **以用户体验为中心的交互设计**
  - 重命名采用行内编辑 + 图标按钮，避免额外弹窗打断流程。
  - 聊天窗口自动滚动到底部，并在用户向上滚动查看历史时智能关闭“强制跟随”。
  - 流式输出和代码高亮增强了 AI 回复的可读性与“智能感”。

## 七、技术实现方案梳理

- **路由与页面结构**
  - 使用 Vue Router 管理路由，但聊天主界面实际上集中在 `AIChat.vue` + `ChatRecord.vue` 这两个核心组件中。
  - 通过 `router-view` 的插槽形式给 `ChatRecord` 传递 `chat-id` 等参数，便于未来扩展成多种聊天视图。

- **状态管理与组件通信**
  - 用户信息（如 token、角色）使用 Pinia 的 `user` store 维护，Axios 拦截器会自动从 store 中注入 `Authorization` 头。
  - 会话列表状态保存在 `AIChat.vue` 的本地 `ref` 中，不额外引入全局 store，降低复杂度。
  - 新建会话后通过 `@chat-created` 事件将新建结果从 `ChatRecord` 传回 `AIChat`，统一更新左侧列表与当前选中 ID。

- **流式输出实现**
  - 真实模式：使用 `@microsoft/fetch-event-source` 连接 SSE 接口 `/api/v1/assistant/chat`，逐条接收数据片段，通过 `onChunk` 回调写入缓冲区，并以定时器实现打字机效果。
  - 开发模式：如果是 `import.meta.env.DEV`，`sendMessage` 会读取 `mock_chat_stream.json` 或预设长文本，模拟分片推送，UI 无需区分真实/Mock 来源。

- **分页与滚动体验**
  - 采用了无限滚动的加载方式，从而避免初次渲染时页面数据量过大导致的性能问题。
  - `ChatRecord` 使用 `pageNum + pageSize + total` 管理分页，从后端按照“最新在前”的顺序拉取，再在前端反转为时间正序展示。
  - 监听消息容器的 `scroll` 事件：
    - 接近顶部时触发 `loadMoreMessages` 追加旧消息，并通过高度差修正 `scrollTop`，保证视口位置稳定。
    - 接近底部时开启自动滚动；用户上滑一段距离后关闭自动滚动，避免阅读时被新消息打断。

- **Markdown、代码高亮与复制功能**
  - 使用 `marked + DOMPurify` 解析并安全渲染 Markdown 内容。
  - 使用 `highlight.js` 对代码块进行高亮，并为每个代码块注入“复制”按钮，通过 `navigator.clipboard` 实现一键复制。
  - 普通消息也提供复制按钮，用户可以方便地复用历史问题或回答。
